use secrecy::ExposeSecret;
use sqlx::PgPool;
use std::net::TcpListener;
use tokio::join;

use newsletter::configuration::ApplicationConfig;
use newsletter::{configuration, startup, telemetry};

// Tip: install `cargo expand` to inspect the boilerplate code generated by the `tokio::main`
// procedural macro:
// 1. `rustup toolchain install nightly --allow-downgrade` (if not yet installed)
// 2. `cargo +nightly expand --bin newsletter`
#[tokio::main]
async fn main() -> std::io::Result<()> {
    init_telemetry();
    let config = configuration::parse().expect("Failed to parse the application config");
    let (listener, pool) = join!(init_listener(&config), init_connection_pool(&config));
    init_db_migrations(&config, &pool).await;

    startup::run_server(listener, pool)?.await
}

fn init_telemetry() {
    let name = String::from("newsletter");
    let directives = "info";
    let make_writer = std::io::stdout;
    let subscriber = telemetry::get_subscriber(name, directives, make_writer);
    telemetry::init_subscriber(subscriber);
}

async fn init_listener(config: &ApplicationConfig) -> TcpListener {
    config
        .server
        .listener()
        .expect("Failed to produce the application listener")
}

async fn init_connection_pool(config: &ApplicationConfig) -> PgPool {
    PgPool::connect(config.database.connection_string().expose_secret())
        .await
        .expect("Failed to connect to the database")
}

async fn init_db_migrations(config: &ApplicationConfig, pool: &PgPool) {
    if config.database.migrate {
        tracing::info!("Running database migrations");
        sqlx::migrate!("./migrations")
            .run(pool)
            .await
            .expect("Failed to migrate the database");
    }
}
