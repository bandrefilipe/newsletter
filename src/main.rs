use newsletter::{configuration, startup};
use sqlx::PgPool;
use tracing_bunyan_formatter::{BunyanFormattingLayer, JsonStorageLayer};
use tracing_log::LogTracer;
use tracing_subscriber::layer::SubscriberExt;
use tracing_subscriber::{EnvFilter, Registry};

// Tip: install `cargo expand` to inspect the boilerplate code generated by the `tokio::main`
// procedural macro:
// 1. `rustup toolchain install nightly --allow-downgrade` (if not yet installed)
// 2. `cargo +nightly expand --bin newsletter`
#[tokio::main]
async fn main() -> std::io::Result<()> {
    LogTracer::init().expect("Failed to set the logger");

    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));
    let formatting_layer = BunyanFormattingLayer::new("newsletter".into(), std::io::stdout);
    let subscriber = Registry::default()
        .with(env_filter)
        .with(JsonStorageLayer)
        .with(formatting_layer);
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set the tracing subscriber");

    let config = configuration::parse().expect("Failed to parse the application config");

    let listener = config
        .server
        .listener()
        .expect("Failed to produce the application listener");

    let pool = PgPool::connect(&config.database.connection_string())
        .await
        .expect("Failed to connect to the database");

    if config.database.migrate {
        tracing::info!("Running database migrations");
        sqlx::migrate!("./migrations")
            .run(&pool)
            .await
            .expect("Failed to migrate the database");
    }

    startup::run_server(listener, pool)?.await
}
